using StaticArrays, SimplexSplitting, Distributions


function potentially_intersecting_simplices2(t::Triangulation, image_i::Int)
    inds_potential_simplices = Int[]

    n_simplices = length(t.radii)

    @inbounds for i = 1:n_simplices
        dist_difference = ((t.centroids_im[image_i] - t.centroids[i]).' *
                            (t.centroids_im[image_i] - t.centroids[i]) - (t.radii_im[image_i] + t.radii[i])^2)[1]
        if dist_difference < 0
            push!(inds_potential_simplices, i)
        end
    end
    return inds_potential_simplices
end

"""
Returns a matrix of convex coefficients to construct points contained within
a `dim`-dimensional simplex. Coefficients can either be random (generated
according to a uniform distribution) or be constructed such that the resulting
points are uniformly distributed within the simplex (generated by shape-preserving
splitting a generic simplex). The `sample_randomly` argument controls this
behaviour.

The default is to not sample randomly (`sample_randomly = false`). In this case,
you won't get the exact number of convex coefficient sets you want, but the
smallest number of set of coefficients such that you have *at least* `n_pts`
convex coefficient sets.

If `sample_randomly = true`, you get as many convex coefficient combinations as
`n_pts`.
"""
function get_coeffs(dim::Int, n_randpts::Int, sample_randomly::Bool)
    # Create a set of convex coefficients to be used for all simplices
    if sample_randomly
        convex_coeffs = rand(Distributions.Uniform(0, 1), n_randpts, dim + 1)
        convex_coeffs .= convex_coeffs ./ sum(convex_coeffs, 2)
    else
        minimum_split_factor = ceil(Int, n_randpts^(1 / dim))[1]
        coeffs = SimplexSplitting.even_sampling_rules(dim, minimum_split_factor).'
        convex_coeffs = Size(size(coeffs, 1), dim + 1)(coeffs)
    end

    convex_coeffs.'
end

"""
Prepares the triangulation for a discrete approximation of the Markov matrix.
Creates alternative representations of the simplices that allow for efficient
(mostly non-allocating) checking if a point lies inside a simplex.
"""
function prepare_mm_dd(t::Triangulation)

    n_simplices = size(t.simplex_inds, 1)
    n_vertices = size(t.simplex_inds, 2)
    dim = n_vertices - 1

    # The [:, j, i] th entry of these two arrays holds the jth vertex of the
    # ith simplex, but instead of having just `dim` vertices, we append a `1`
    # to the end of the vectors. This allows for efficent (non-allocating)
    # computation within the `contains_point_lessalloc!` function. If we instead
    # would have appended the 1's inside that function, we would be performing
    # memory-allocating operations, which are very expensive. Doing this instead
    # gives orders of magnitude speed-ups for sufficiently large triangulations.
    S1 = Array{Float64}(dim + 1, dim + 1, n_simplices)
    IS1 = Array{Float64}(dim + 1, dim + 1, n_simplices)

    # Collect simplices in the form of (dim+1)^2-length column vectors. This
    # also helps with the
    simplices = Size((dim+1)^2, n_simplices)(zeros((dim+1)^2, n_simplices))
    imsimplices = Size((dim+1)^2, n_simplices)(zeros((dim+1)^2, n_simplices))

    for i in 1:n_simplices
        for j in 1:n_vertices
            S1[:, j, i] = vcat(t.points[t.simplex_inds[i, j], :], 1.0)
            IS1[:, j, i] = vcat(t.impoints[t.simplex_inds[i, j], :], 1.0)
        end

        simplices[:, i] = reshape(S1[:, :, i], (dim+1)^2)
        imsimplices[:, i] = reshape(IS1[:, :, i], (dim+1)^2)
    end

    return simplices, imsimplices
end

"""
Checks if a point lies inside a simplex `sx`. The simplex is represented as a
column vector [V1; V2; V3; V4], where V1 is the vertex represented as a
(dim+1)-length column vector, where the first 1:dim entries is the vertex
coordinates and the last entry is a 1. The reason for appending the 1 is for
efficiency when computing determinants (appending row vectors to matrices is
very expensive, because it allocates memory, so we rather reformat our simplices
beforehand).

`s_arr` is a temporary array of the same size as `sx`. `signs` is a
(dim + 1)-length vector containing the signs of the determinants of the
(at most) (dim + 1) matrices we need to check to determine whether the point
lies inside the simplex or not. `dim` is just the dimension of the space.
"""
function contains_point_lessalloc!(signs, s_arr, sx, point, dim::Int)
    # Redefine the temporary simplex. This is in-place, so we don't allocate
    # memory. We could also have re-initialised `signs`, but since we're never
    # comparing more than two consecutive signs, this is not necessary.
    s_arr .= 0.0
    s_arr .= s_arr .+ sx
    signs .= 0.0

    # Replace first vertex with the point
    s_arr[1:dim] = point

    # Compute the first sign
    signs[1] = sign(det(reshape(s_arr, dim + 1, dim + 1)))
    s_arr .= 0.0
    s_arr .= s_arr .+ sx

    for κ = 2:(dim) # Check remaining signs and stop if sign changes
        # Replace the ith vertex with the point we're cheking (leaving the
        # 1 appended to Vi intact.)
        s_arr[(dim + 1)*(κ - 1)+1:((dim + 1)*(κ - 1)+ 1 + dim - 1)] = point
        signs[κ] = sign(det(reshape(s_arr, dim + 1, dim + 1)))

        if !(signs[κ] == signs[κ - 1])
           return false
        end
        s_arr .= 0.0
        s_arr .= s_arr .+ sx
    end

    # Last the last vertex with the point in question
    s_arr[((dim + 1)*(dim)+1):((dim+1)^2-1)] = point
    signs[end] = sign(det(reshape(s_arr, dim + 1, dim + 1)))

    if !(signs[end] == signs[end - 1])
       return false
    end

    return true
end


"""
Discrete approximation of the Markov matrix from a precomputed triangulation `t`.
Instead of using exact volumes, we here estimate intersections between simplices
by using the proportions of points projected forward in time that fall into
the ensemble of target simplices.

Use `sample_randomly = false` to represent simplices by a uniform grid of points
and `sample_randomly = true` to represent simplices by random points.
"""
function mm_dd2(t::Triangulation;
                n_randpts::Int = 100,
                sample_randomly::Bool = false)

    # Some constants used throughout the funciton
    n_simplices = size(t.simplex_inds, 1)
    dim = size(t.points, 2)

    #=
    # Prepare memory-efficient representations of the simplices, and the convex
    # coefficients needed to generate points.
    =#
    simplices, imsimplices = prepare_mm_dd(t)

    convex_coeffs = get_coeffs(dim, n_randpts, sample_randomly)

    #=
    # update number of points in case a regular grid of points was employed
    # (if so, because the number of subsimplices generated by the
    # shape-preserving splitting depends only on the dimension of the space,
    # there will be more points than we asked for).
    =#
    n_coeffs = maximum(size(convex_coeffs))


    # Pre-allocated arrays (SizedArrays, for efficiency)
    pt          = Size(dim)(zeros(Float64, dim))
    s_arr       = Size((dim+1)^2)(zeros(Float64, (dim+1)^2))
    signs       = Size(dim + 1)(zeros(Float64, dim + 1))

    # Re-arrange simplices so that look-up is a bit more efficient
    simplex_arrs = Vector{Array{Float64, 2}}(n_simplices)
    imsimplex_arrs = Vector{Array{Float64, 2}}(n_simplices)
    for i in 1:n_simplices
        simplex_arrs[i] = t.points[t.simplex_inds[i, :], :]
        imsimplex_arrs[i] = t.impoints[t.simplex_inds[i, :], :]
    end

    # The Markov matrix
    M = zeros(Float64, n_simplices, n_simplices)
    for i in 1:n_simplices
        inds = potentially_intersecting_simplices2(t, i)
        is = imsimplex_arrs[i]

        for k in 1:n_coeffs
            pt = convex_coeffs[:, k].' * is

            for j in inds
                sx = simplices[:, j]
                if contains_point_lessalloc!(signs, s_arr, sx, pt, dim)
                    M[j, i] += 1.0
                end
            end

        end
    end
    return M.' ./ n_coeffs
end

function mm_dd3(t::Triangulation, simplices, convex_coeffs)

    # Some constants used throughout the funciton
    n_simplices = size(t.simplex_inds, 1)
    dim = size(t.points, 2)

    #=
    # update number of points in case a regular grid of points was employed
    # (if so, because the number of subsimplices generated by the
    # shape-preserving splitting depends only on the dimension of the space,
    # there will be more points than we asked for).
    =#
    n_coeffs = maximum(size(convex_coeffs))


    # Pre-allocated arrays (SizedArrays, for efficiency)
    pt          = Size(dim)(zeros(Float64, dim))
    s_arr       = Size((dim+1)^2)(zeros(Float64, (dim+1)^2))
    signs       = Size(dim + 1)(zeros(Float64, dim + 1))

    # Re-arrange simplices so that look-up is a bit more efficient
    simplex_arrs = Vector{Array{Float64, 2}}(n_simplices)
    imsimplex_arrs = Vector{Array{Float64, 2}}(n_simplices)
    for i in 1:n_simplices
        simplex_arrs[i] = t.points[t.simplex_inds[i, :], :]
        imsimplex_arrs[i] = t.impoints[t.simplex_inds[i, :], :]
    end

    # The Markov matrix
    M = zeros(Float64, n_simplices, n_simplices)

    for i in 1:n_simplices
        inds = potentially_intersecting_simplices2(t, i)
        is = imsimplex_arrs[i]

        @views  for k in 1:n_coeffs
            pt = convex_coeffs[:, k].' * is

            #@show i, k, pt
            for j in inds
                sx = simplices[:, j]
                if contains_point_lessalloc!(signs, s_arr, sx, pt, dim)
                    M[j, i] += 1.0
                end
            end

        end
    end
    return M.' ./ n_coeffs
end
